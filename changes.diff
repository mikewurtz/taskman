diff --git a/.gitignore b/.gitignore
index 351e497..bcf7dc0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,10 @@
 
 # ignore binaries
 /bin
+
+# ignore vs code
+.vscode
+
+# ignore test binaries
+**/testbin
+
diff --git a/Makefile b/Makefile
index fc2c665..a29fb96 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,4 @@
-.PHONY: all lint build build-race generate-proto test clean
+.PHONY: all lint build build-race generate-proto test clean unit-test test-integration test-all test-integration-specific
 
 BINDIR      := bin
 CMD_CLI     := cmd/cli/main.go
@@ -28,8 +28,26 @@ generate-proto:
 		--go-grpc_out=$(GEN_DIR) --go-grpc_opt=paths=source_relative \
 		$(PROTO_FILE)
 
-test:
-	go test -v -race -cover ./...
+unit-test:
+	# Run unit tests as non-root
+	@echo "==> Running unit tests (non-root)"
+	go test -v -race -cover $$(go list ./... | grep -v 'github.com/mikewurtz/taskman/tests$$')
+
+test-integration:
+	# Run integration tests as root since cgroup creation is privileged
+	@echo "==> Running privileged tests (as root)"
+	go test -c -race -o tests/testbin ./tests/integration && \
+	sudo ./tests/testbin -test.v
+
+test-all: unit-test test-integration
+
+test-integration-specific:
+	@if [ -z "$(FUNC)" ]; then \
+		echo "Error: specify the test function with FUNC=<TestName>"; \
+		exit 1; \
+	fi; \
+	go test -c -o tests/testbin ./tests/integration && \
+	sudo ./tests/testbin -test.v -test.run "^$(FUNC)$$"
 
 clean:
 	rm -rf $(BINDIR) $(GEN_DIR)
diff --git a/cmd/cli/commands/status.go b/cmd/cli/commands/status.go
index b578d80..5ab619e 100644
--- a/cmd/cli/commands/status.go
+++ b/cmd/cli/commands/status.go
@@ -54,6 +54,12 @@ Options:
 			}
 		}()
 
-		return manager.GetTaskStatus(cmd.Context(), taskID)
+		status, err := manager.GetTaskStatus(cmd.Context(), taskID)
+		if err != nil {
+			return fmt.Errorf("failed to get task status: %w", err)
+		}
+		// TODO should this be to fmt.Printf?
+		fmt.Println(status.String())
+		return nil
 	},
 }
diff --git a/cmd/server/main.go b/cmd/server/main.go
index f44f166..8848d82 100644
--- a/cmd/server/main.go
+++ b/cmd/server/main.go
@@ -22,7 +22,7 @@ var rootCmd = &cobra.Command{
 over a secure mTLS connection.`,
 	Example: `$ taskman-server --server-address localhost:50051`,
 	RunE: func(cmd *cobra.Command, args []string) error {
-		server, err := server.New(serverAddr)
+		server, err := server.New(serverAddr, cmd.Context())
 		if err != nil {
 			return fmt.Errorf("failed to initialize server: %w", err)
 		}
@@ -34,16 +34,19 @@ over a secure mTLS connection.`,
 			}
 		}()
 
-		// Set up signal handling for SIGINT and SIGTERM
-		ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
-		defer stop()
-
 		log.Println("Taskman server is running. Press Ctrl+C to stop.")
 
 		// Use ctx to block until a signal is received:
-		<-ctx.Done()
+		<-cmd.Context().Done()
 		log.Println("Shutdown signal received. Stopping server...")
+
+		// Stop accepting new connections and attempt to clean up all tasks
 		server.Stop()
+
+		// Wait for all tasks to complete
+		log.Println("Waiting for tasks to complete...")
+		server.WaitForTasks()
+
 		log.Println("Server stopped cleanly.")
 		return nil
 	},
@@ -56,7 +59,9 @@ func init() {
 }
 
 func main() {
-	if err := rootCmd.Execute(); err != nil {
+	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
+	defer stop()
+	if err := rootCmd.ExecuteContext(ctx); err != nil {
 		log.Println(err)
 		os.Exit(1)
 	}
diff --git a/go.mod b/go.mod
index c1582a3..5e5518c 100644
--- a/go.mod
+++ b/go.mod
@@ -3,6 +3,7 @@ module github.com/mikewurtz/taskman
 go 1.24.1
 
 require (
+	github.com/google/uuid v1.6.0
 	github.com/stretchr/testify v1.10.0
 	google.golang.org/grpc v1.71.1
 	google.golang.org/protobuf v1.36.6
diff --git a/internal/grpc/client/manager.go b/internal/grpc/client/manager.go
index f5b9f57..6f1c383 100644
--- a/internal/grpc/client/manager.go
+++ b/internal/grpc/client/manager.go
@@ -1,8 +1,11 @@
 package client
 
 import (
+	"bytes"
 	"context"
 	"fmt"
+	"text/tabwriter"
+	"time"
 
 	"google.golang.org/grpc"
 
@@ -45,15 +48,78 @@ func (m *Manager) StartTask(ctx context.Context, command string, args []string)
 	return resp.TaskId, nil
 }
 
+type TaskStatus struct {
+	TaskID            string
+	Status            string
+	StartTime         time.Time
+	EndTime           time.Time
+	ExitCode          *int32
+	ProcessID         int32
+	TerminationSignal string
+	TerminationSource string
+}
+
+func (t *TaskStatus) String() string {
+	var buf bytes.Buffer
+	w := tabwriter.NewWriter(&buf, 0, 0, 2, ' ', 0)
+	fmt.Fprintln(w, "TASK ID\tSTART TIME\tPID\tSTATUS\tEXIT CODE\tSIGNAL\tSTOP SOURCE\tEND TIME")
+	fmt.Fprintln(w, "-------\t----------\t---\t------\t---------\t------\t-----------\t--------")
+
+	startTime := t.StartTime.Format("2006-01-02 15:04:05")
+
+	endTime := "-"
+	if !t.EndTime.IsZero() {
+		endTime = t.EndTime.Format("2006-01-02 15:04:05")
+	}
+
+	exitStr := "-"
+	if t.ExitCode != nil {
+		exitStr = fmt.Sprintf("%d", *t.ExitCode)
+	}
+
+	signal := t.TerminationSignal
+	if signal == "" {
+		signal = "-"
+	}
+
+	source := t.TerminationSource
+	if source == "" {
+		source = "-"
+	}
+
+	fmt.Fprintf(w, "%s\t%s\t%d\t%s\t%s\t%s\t%s\t%s\n",
+		t.TaskID,
+		startTime,
+		t.ProcessID,
+		t.Status,
+		exitStr,
+		signal,
+		source,
+		endTime,
+	)
+	w.Flush()
+	return buf.String()
+}
+
 // GetTaskStatus gets the status of a task by its ID
-func (m *Manager) GetTaskStatus(ctx context.Context, taskID string) error {
-	_, err := m.client.GetTaskStatus(ctx, &pb.TaskStatusRequest{TaskId: taskID})
+func (m *Manager) GetTaskStatus(ctx context.Context, taskID string) (*TaskStatus, error) {
+	pbStatus, err := m.client.GetTaskStatus(ctx, &pb.TaskStatusRequest{TaskId: taskID})
 	if err != nil {
-		return fmt.Errorf("error getting task status: %w", err)
+		return nil, fmt.Errorf("error getting task status: %w", err)
 	}
 
-	// TODO handle task status ouput once implemented
-	return nil
+	returnStatus := &TaskStatus{
+		TaskID:            pbStatus.TaskId,
+		Status:            pbStatus.Status.String(),
+		StartTime:         pbStatus.StartTime.AsTime(),
+		EndTime:           pbStatus.EndTime.AsTime(),
+		ExitCode:          pbStatus.ExitCode,
+		ProcessID:         pbStatus.ProcessId,
+		TerminationSignal: pbStatus.TerminationSignal,
+		TerminationSource: pbStatus.TerminationSource,
+	}
+
+	return returnStatus, nil
 }
 
 // StreamTaskOutput streams the output of a task by its ID
diff --git a/internal/grpc/server/server.go b/internal/grpc/server/server.go
index 21ca23d..cd3b7f2 100644
--- a/internal/grpc/server/server.go
+++ b/internal/grpc/server/server.go
@@ -1,6 +1,7 @@
 package server
 
 import (
+	"context"
 	"crypto/tls"
 	"fmt"
 	"log"
@@ -18,11 +19,12 @@ import (
 type Server struct {
 	grpcServer *grpc.Server
 	listener   net.Listener
+	taskServer *taskManagerServer
 }
 
 // New sets up the gRPC server and listener with mTLS authentication using TLS v1.3
 // Includes interceptors for injecting the client CN into the context for unary and stream calls
-func New(serverAddr string) (*Server, error) {
+func New(serverAddr string, ctx context.Context) (*Server, error) {
 	cert, err := basegrpc.LoadTLSCert(certs.ServerCertName)
 	if err != nil {
 		return nil, fmt.Errorf("loading server cert: %w", err)
@@ -51,7 +53,8 @@ func New(serverAddr string) (*Server, error) {
 		grpc.ChainUnaryInterceptor(ExtractClientCNInterceptor),
 		grpc.ChainStreamInterceptor(ExtractClientCNStreamInterceptor))
 
-	pb.RegisterTaskManagerServer(grpcServer, NewTaskManagerServer())
+	taskServer := NewTaskManagerServer(ctx)
+	pb.RegisterTaskManagerServer(grpcServer, taskServer)
 
 	lis, err := net.Listen("tcp", serverAddr)
 	if err != nil {
@@ -61,6 +64,7 @@ func New(serverAddr string) (*Server, error) {
 	return &Server{
 		grpcServer: grpcServer,
 		listener:   lis,
+		taskServer: taskServer,
 	}, nil
 }
 
@@ -80,3 +84,7 @@ func (s *Server) Addr() string {
 func (s *Server) Stop() {
 	s.grpcServer.GracefulStop()
 }
+
+func (s *Server) WaitForTasks() {
+	s.taskServer.taskManager.WaitForTasks()
+}
diff --git a/internal/grpc/server/task_manager.go b/internal/grpc/server/task_manager.go
index cbda735..6e09701 100644
--- a/internal/grpc/server/task_manager.go
+++ b/internal/grpc/server/task_manager.go
@@ -7,34 +7,64 @@ import (
 
 	"google.golang.org/grpc/codes"
 	"google.golang.org/grpc/status"
+	"google.golang.org/protobuf/types/known/timestamppb"
+
+	"github.com/mikewurtz/taskman/internal/task"
+	taskmanager "github.com/mikewurtz/taskman/internal/task/manager"
 )
 
-func NewTaskManagerServer() *taskManagerServer {
-	return &taskManagerServer{}
+func NewTaskManagerServer(ctx context.Context) *taskManagerServer {
+	return &taskManagerServer{
+		taskManager: taskmanager.NewTaskManager(ctx),
+	}
 }
 
 type taskManagerServer struct {
 	// this gives us a forward compatible implementation to extend later
 	pb.UnimplementedTaskManagerServer
+	taskManager *taskmanager.TaskManager
 }
 
-// TODO: Once we have a real implementation, we will break up this file into multiple files
-// These functions will be moved to the appropriate files and utilize the reuseable library
-// for managing the linux processes.
-
 // StartTask
 func (s *taskManagerServer) StartTask(ctx context.Context, req *pb.StartTaskRequest) (*pb.StartTaskResponse, error) {
-	return nil, status.Error(codes.Unimplemented, "StartTask not implemented")
+	taskID, err := s.taskManager.StartTask(ctx, req.Command, req.Args)
+	if err != nil {
+		return nil, task.TaskErrorToGRPC(err)
+	}
+	return &pb.StartTaskResponse{TaskId: taskID}, nil
 }
 
 // StopTask
 func (s *taskManagerServer) StopTask(ctx context.Context, req *pb.StopTaskRequest) (*pb.StopTaskResponse, error) {
-	return nil, status.Errorf(codes.Unimplemented, "StopTask not implemented")
+	if err := s.taskManager.StopTask(ctx, req.TaskId); err != nil {
+		return nil, task.TaskErrorToGRPC(err)
+	}
+	return &pb.StopTaskResponse{}, nil
 }
 
 // GetTaskStatus
 func (s *taskManagerServer) GetTaskStatus(ctx context.Context, req *pb.TaskStatusRequest) (*pb.TaskStatusResponse, error) {
-	return nil, status.Errorf(codes.Unimplemented, "GetTaskStatus not implemented")
+	taskObj, err := s.taskManager.GetTaskStatus(ctx, req.TaskId)
+	if err != nil {
+		return nil, task.TaskErrorToGRPC(err)
+	}
+	status, err := task.StatusToProto(taskObj.Status)
+	if err != nil {
+		return nil, task.TaskErrorToGRPC(err)
+	}
+
+	returnStatus := &pb.TaskStatusResponse{
+		TaskId:            taskObj.ID,
+		ProcessId:         int32(taskObj.ProcessID),
+		Status:            status,
+		StartTime:         timestamppb.New(taskObj.StartTime),
+		EndTime:           timestamppb.New(taskObj.EndTime),
+		ExitCode:          taskObj.ExitCode,
+		TerminationSignal: taskObj.TerminationSignal,
+		TerminationSource: taskObj.TerminationSource,
+	}
+
+	return returnStatus, nil
 }
 
 // StreamTaskOutput
diff --git a/internal/task/cgroups/cgroup.go b/internal/task/cgroups/cgroup.go
new file mode 100644
index 0000000..0bbea7a
--- /dev/null
+++ b/internal/task/cgroups/cgroup.go
@@ -0,0 +1,98 @@
+package cgroups
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"path/filepath"
+	"strings"
+	"syscall"
+	"time"
+)
+
+const baseCgroupPath = "/sys/fs/cgroup/"
+
+func CreateCgroupForTask(taskID string) (*os.File, error) {
+	cgroupPath := filepath.Join(baseCgroupPath, taskID)
+
+	if err := os.MkdirAll(cgroupPath, 0755); err != nil {
+		return nil, fmt.Errorf("failed to create cgroup directory %s: %w", cgroupPath, err)
+	}
+
+	// Configure CPU limits: Quota 200000 µs and Period 1000000 µs.
+	cpuMaxPath := filepath.Join(cgroupPath, "cpu.max")
+	cpuConfig := "200000 1000000"
+	if err := os.WriteFile(cpuMaxPath, []byte(cpuConfig), 0644); err != nil {
+		return nil, fmt.Errorf("failed to write CPU config to %s: %w", cpuMaxPath, err)
+	}
+
+	// Configure memory limit: 64M.
+	memoryMaxPath := filepath.Join(cgroupPath, "memory.max")
+	memoryConfig := "64M"
+	if err := os.WriteFile(memoryMaxPath, []byte(memoryConfig), 0644); err != nil {
+		return nil, fmt.Errorf("failed to write memory config to %s: %w", memoryMaxPath, err)
+	}
+
+	// io is not always enabled on the system and can be enabled by:
+	// echo "+io" | sudo tee /sys/fs/cgroup/cgroup.subtree_control
+	// Configure IO limits: device "8:0" with max read and write bandwidth 1048576 (1 MB/s).
+	ioMaxPath := filepath.Join(cgroupPath, "io.max")
+	ioConfig := "8:0 rbps=1048576 wbps=1048576"
+	if err := os.WriteFile(ioMaxPath, []byte(ioConfig), 0644); err != nil {
+		return nil, fmt.Errorf("failed to write IO config to %s: %w", ioMaxPath, err)
+	}
+
+	// Open the cgroup directory as a file descriptor
+	cgFd, err := os.Open(cgroupPath)
+	if err != nil {
+		return nil, fmt.Errorf("failed to open cgroup path: %w", err)
+	}
+
+	return cgFd, nil
+}
+
+// RemoveCgroupForTask removes the cgroup for a task
+func RemoveCgroupForTask(taskID string) error {
+	cgroupPath := filepath.Join(baseCgroupPath, taskID)
+	timeout := time.After(5 * time.Second)
+	ticker := time.NewTicker(100 * time.Millisecond)
+	defer ticker.Stop()
+
+	for {
+		select {
+		case <-timeout:
+			return fmt.Errorf("failed to remove cgroup directory %s: timeout reached", cgroupPath)
+		case <-ticker.C:
+			// attempt to remove the cgroup directory
+			if err := os.Remove(cgroupPath); err != nil {
+				// If the error is due to the directory not being empty or busy, continue waiting.
+				if errors.Is(err, syscall.ENOTEMPTY) || errors.Is(err, syscall.EBUSY) {
+					continue
+				}
+				// For any other error, return immediately.
+				return fmt.Errorf("failed to remove cgroup directory %s: %w", cgroupPath, err)
+			}
+			// Successfully removed the directory.
+			return nil
+		}
+	}
+}
+
+func CheckIfOOMKilled(taskID string) (bool, error) {
+	cgroupPath := filepath.Join(baseCgroupPath, taskID)
+	oomPath := filepath.Join(cgroupPath, "memory.events")
+
+	data, err := os.ReadFile(oomPath)
+	if err != nil {
+		return false, fmt.Errorf("failed to read memory.events: %w", err)
+	}
+
+	lines := strings.SplitSeq(string(data), "\n")
+	for line := range lines {
+		if fields := strings.Fields(line); len(fields) == 2 && fields[0] == "oom_kill" && fields[1] == "1" {
+			return true, nil
+		}
+	}
+
+	return false, nil
+}
diff --git a/internal/task/error.go b/internal/task/error.go
new file mode 100644
index 0000000..0f26df4
--- /dev/null
+++ b/internal/task/error.go
@@ -0,0 +1,93 @@
+package task
+
+import (
+	"errors"
+	"fmt"
+
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+// ErrorCode represents the type of error that occurred
+type ErrorCode int
+
+const (
+	// ErrInvalidArgument indicates that the provided arguments are invalid
+	ErrInvalidArgument ErrorCode = iota
+	// ErrNotFound indicates that the requested resource was not found
+	ErrNotFound
+	// ErrAlreadyTerminated indicates that the task has already terminated
+	ErrAlreadyTerminated
+	// ErrFailedPrecondition indicates that the task is in a failed precondition state
+	ErrFailedPrecondition
+	// ErrInternal indicates an internal system error
+	ErrInternal
+)
+
+// TaskError represents an error that occurred during task management
+type TaskError struct {
+	Code    ErrorCode
+	Message string
+	Err     error
+}
+
+func (e *TaskError) Error() string {
+	if e.Err != nil {
+		return e.Message + ": " + e.Err.Error()
+	}
+	return e.Message
+}
+
+func (e *TaskError) Unwrap() error {
+	return e.Err
+}
+
+// NewTaskError creates a new TaskError with optional formatting
+func NewTaskError(code ErrorCode, format string, args ...any) *TaskError {
+	return &TaskError{
+		Code:    code,
+		Message: fmt.Sprintf(format, args...),
+	}
+}
+
+// NewTaskErrorWithErr creates a new TaskError with an underlying error
+func NewTaskErrorWithErr(code ErrorCode, format string, err error, args ...any) *TaskError {
+	return &TaskError{
+		Code:    code,
+		Message: fmt.Sprintf(format, args...),
+		Err:     err,
+	}
+}
+
+// IsTaskError checks if an error is a TaskError
+func IsTaskError(err error) (*TaskError, bool) {
+	var taskErr *TaskError
+	if errors.As(err, &taskErr) {
+		return taskErr, true
+	}
+	return nil, false
+}
+
+// handleTaskError converts a TaskError to a gRPC status error
+func TaskErrorToGRPC(err error) error {
+	if taskErr, ok := IsTaskError(err); ok {
+		var code codes.Code
+		switch taskErr.Code {
+		case ErrInvalidArgument:
+			code = codes.InvalidArgument
+		case ErrNotFound:
+			code = codes.NotFound
+		case ErrAlreadyTerminated:
+			code = codes.FailedPrecondition
+		case ErrFailedPrecondition:
+			code = codes.FailedPrecondition
+		case ErrInternal:
+			code = codes.Internal
+		default:
+			code = codes.Internal
+		}
+		return status.Error(code, taskErr.Error())
+	}
+	// If it's not a TaskError, return it as an internal error
+	return status.Error(codes.Internal, err.Error())
+}
diff --git a/internal/task/manager/getstatus.go b/internal/task/manager/getstatus.go
new file mode 100644
index 0000000..5617455
--- /dev/null
+++ b/internal/task/manager/getstatus.go
@@ -0,0 +1,40 @@
+package task
+
+import (
+	"context"
+	"fmt"
+
+	basegrpc "github.com/mikewurtz/taskman/internal/grpc"
+	basetask "github.com/mikewurtz/taskman/internal/task"
+)
+
+func (tm *TaskManager) GetTaskStatus(ctx context.Context, taskID string) (*Task, error) {
+	task, err := tm.GetTask(taskID)
+	if err != nil {
+		return nil, err
+	}
+
+	caller := ctx.Value(basegrpc.ClientIDKey).(string)
+	if task.ClientID != caller && caller != "admin" {
+		return nil, basetask.NewTaskError(basetask.ErrNotFound, fmt.Sprintf("task with id %s not found", taskID), nil)
+	}
+
+	task.mu.RLock()
+	defer task.mu.RUnlock()
+
+	copy := &Task{
+		ID:                task.ID,
+		ClientID:          task.ClientID,
+		ProcessID:         task.ProcessID,
+		Status:            task.Status,
+		StartTime:         task.StartTime,
+		EndTime:           task.EndTime,
+		TerminationSignal: task.TerminationSignal,
+		TerminationSource: task.TerminationSource,
+	}
+	if task.ExitCode != nil {
+		ec := *task.ExitCode
+		copy.ExitCode = &ec
+	}
+	return copy, nil
+}
diff --git a/internal/task/manager/manager.go b/internal/task/manager/manager.go
new file mode 100644
index 0000000..d66dc73
--- /dev/null
+++ b/internal/task/manager/manager.go
@@ -0,0 +1,67 @@
+package task
+
+import (
+	"context"
+	"sync"
+	"time"
+
+	basetask "github.com/mikewurtz/taskman/internal/task"
+)
+
+type TaskManager struct {
+	mu sync.RWMutex
+	// task map by task ID
+	tasksMapByID map[string]*Task
+	ctx          context.Context
+}
+
+type Task struct {
+	mu                sync.RWMutex
+	ID                string
+	ClientID          string
+	ProcessID         int
+	Status            int
+	StartTime         time.Time
+	ExitCode          *int32
+	TerminationSignal string
+	TerminationSource string
+	EndTime           time.Time
+	done              chan struct{}
+}
+
+func NewTaskManager(ctx context.Context) *TaskManager {
+	return &TaskManager{
+		tasksMapByID: make(map[string]*Task),
+		ctx:          ctx,
+	}
+}
+
+func (tm *TaskManager) AddTask(task *Task) {
+	tm.mu.Lock()
+	defer tm.mu.Unlock()
+	task.done = make(chan struct{})
+	tm.tasksMapByID[task.ID] = task
+}
+
+func (tm *TaskManager) WaitForTasks() {
+	tm.mu.RLock()
+	tasks := make([]*Task, 0, len(tm.tasksMapByID))
+	for _, task := range tm.tasksMapByID {
+		tasks = append(tasks, task)
+	}
+	tm.mu.RUnlock()
+
+	for _, task := range tasks {
+		<-task.done
+	}
+}
+
+func (tm *TaskManager) GetTask(taskID string) (*Task, error) {
+	tm.mu.RLock()
+	defer tm.mu.RUnlock()
+	task, ok := tm.tasksMapByID[taskID]
+	if !ok {
+		return nil, basetask.NewTaskError(basetask.ErrNotFound, "task with id %s not found", taskID)
+	}
+	return task, nil
+}
diff --git a/internal/task/manager/monitor.go b/internal/task/manager/monitor.go
new file mode 100644
index 0000000..8721fc1
--- /dev/null
+++ b/internal/task/manager/monitor.go
@@ -0,0 +1,145 @@
+package task
+
+import (
+	"context"
+	"errors"
+	"log"
+	"os/exec"
+	"syscall"
+	"time"
+
+	"github.com/mikewurtz/taskman/internal/task/cgroups"
+
+	basetask "github.com/mikewurtz/taskman/internal/task"
+)
+
+// monitorProcess handles the process completion and status updates
+func (tm *TaskManager) monitorProcess(taskID string, cmd *exec.Cmd) {
+	// Create a channel to receive the process completion
+	done := make(chan error, 1)
+	go func() {
+		done <- cmd.Wait()
+	}()
+
+	// Wait for either the process to complete or the context to be canceled
+	var cmdErr error
+	select {
+	case cmdErr = <-done:
+		// Process completed normally
+	case <-tm.ctx.Done():
+		// Server context was canceled, kill the entire process group
+		if err := syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL); err != nil {
+			log.Printf("Failed to kill process group %d: %v", cmd.Process.Pid, err)
+		}
+		cmdErr = <-done
+	}
+
+	finishTime := time.Now()
+
+	if cmdErr != nil {
+		log.Printf("Task %s failed: %v", taskID, cmdErr)
+	} else {
+		log.Printf("Task %s completed successfully", taskID)
+	}
+
+	var exitCode *int
+	var signal string
+	exitCode, signal = extractProcessExitInfo(cmdErr, cmd)
+
+	task, err := tm.GetTask(taskID)
+	if err != nil {
+		log.Printf("Failed to get task %s: %v", taskID, err)
+		return
+	}
+
+	task.mu.Lock()
+	defer task.mu.Unlock()
+
+	task.EndTime = finishTime
+	if exitCode != nil {
+		ec := int32(*exitCode)
+		task.ExitCode = &ec
+	}
+	task.TerminationSignal = signal
+
+	if oomKilled, err := cgroups.CheckIfOOMKilled(taskID); err != nil {
+		log.Printf("Failed to check if task %s was OOM killed: %v", taskID, err)
+	} else if oomKilled {
+		// OOM kill overrides whatever status was previously inferred
+		task.Status = basetask.JobStatusSignaled
+		task.TerminationSignal = syscall.SIGKILL.String()
+		task.TerminationSource = "oom"
+		task.ExitCode = nil
+	} else if exitCode != nil {
+		if *exitCode == 0 {
+			task.Status = basetask.JobStatusExitedOK
+		} else {
+			task.Status = basetask.JobStatusExitedError
+		}
+	} else {
+		task.Status = basetask.JobStatusSignaled
+		if task.TerminationSource == "" {
+			task.TerminationSource = "system"
+		}
+	}
+
+	// Clean up cgroup after process completes
+	if cleanupErr := cgroups.RemoveCgroupForTask(taskID); cleanupErr != nil {
+		log.Printf("Failed to clean up cgroup after process completion: %v", cleanupErr)
+	}
+
+	// Signal that this task is done
+	close(task.done)
+}
+
+// extractProcessExitInfo extracts the exit code and signal from the command error
+// or from the process state if the command terminated normally
+func extractProcessExitInfo(cmdErr error, cmd *exec.Cmd) (*int, string) {
+	var exitCode *int
+	var signal string
+
+	if cmdErr != nil {
+		// Handle context-related errors
+		if errors.Is(cmdErr, context.DeadlineExceeded) {
+			log.Printf("Command timed out: %v", cmdErr)
+		} else if errors.Is(cmdErr, context.Canceled) {
+			log.Printf("Command context was canceled: %v", cmdErr)
+		}
+
+		// os.PathError and exec.Error are handled when we call cmd.Start()
+		switch e := cmdErr.(type) {
+		case *exec.ExitError:
+			// Process started but exited with non-zero status or was killed
+			if status, ok := e.Sys().(syscall.WaitStatus); ok {
+				if status.Signaled() {
+					signal = status.Signal().String()
+				} else {
+					code := status.ExitStatus()
+					exitCode = &code
+				}
+			} else {
+				log.Printf("Unexpected type in ExitError.Sys(): %T", e.Sys())
+			}
+		default:
+			log.Printf("Unhandled command error type (%T): %v", cmdErr, cmdErr)
+		}
+	} else {
+		// process exited with no error
+		if cmd.ProcessState == nil {
+			log.Printf("Missing ProcessState for completed process, cannot extract exit info")
+			return nil, ""
+		}
+		if status, ok := cmd.ProcessState.Sys().(syscall.WaitStatus); ok {
+			if status.Signaled() {
+				signal = status.Signal().String()
+			} else {
+				code := status.ExitStatus()
+				exitCode = &code
+			}
+		} else {
+			log.Printf("Unexpected type in ProcessState.Sys(): %T", cmd.ProcessState.Sys())
+		}
+	}
+
+	return exitCode, signal
+}
diff --git a/internal/task/manager/start.go b/internal/task/manager/start.go
new file mode 100644
index 0000000..02215fc
--- /dev/null
+++ b/internal/task/manager/start.go
@@ -0,0 +1,88 @@
+package task
+
+import (
+	"context"
+	"log"
+	"os"
+	"os/exec"
+	"syscall"
+	"time"
+
+	"github.com/google/uuid"
+
+	basegrpc "github.com/mikewurtz/taskman/internal/grpc"
+	basetask "github.com/mikewurtz/taskman/internal/task"
+	"github.com/mikewurtz/taskman/internal/task/cgroups"
+)
+
+func (tm *TaskManager) StartTask(ctx context.Context, command string, args []string) (string, error) {
+	clientCN := ctx.Value(basegrpc.ClientIDKey)
+	log.Printf("Starting task for client %s: %s %v", clientCN, command, args)
+
+	if command == "" {
+		return "", basetask.NewTaskError(basetask.ErrInvalidArgument, "command cannot be empty")
+	}
+
+	taskID := uuid.New().String()
+
+	// Create cgroup and get file descriptor
+	cgroupFd, err := cgroups.CreateCgroupForTask(taskID)
+	if err != nil {
+		return "", basetask.NewTaskErrorWithErr(basetask.ErrInternal, "failed to create cgroup", err)
+	}
+
+	// exec.CommandContext() calls cmd.Process.Kill() on context cancelation which kills just the first process
+	// and not the entire process group. We want the whole process group to be killed on context cancelation.
+	// So we later call syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL) to kill the entire process group.
+	cmd := exec.Command(command, args...)
+
+	// Set process attributes. We set the cgroup fields so the process starts in the cgroup rather than having to move it later
+	// We want the pgid so we can kill the entire process group later
+	cmd.SysProcAttr = &syscall.SysProcAttr{
+		Setpgid:     true,
+		UseCgroupFD: true,
+		CgroupFD:    int(cgroupFd.Fd()),
+	}
+
+	// Start the process
+	if err := cmd.Start(); err != nil {
+		// clean up the cgroup so it doesn't leak
+		cgroupFd.Close()
+		if cleanupErr := cgroups.RemoveCgroupForTask(taskID); cleanupErr != nil {
+			log.Printf("Failed to clean up cgroup after process start failure: %v", cleanupErr)
+		}
+		switch e := err.(type) {
+		case *exec.Error:
+			return "", basetask.NewTaskErrorWithErr(basetask.ErrInvalidArgument, "invalid command", e)
+		case *os.PathError:
+			return "", basetask.NewTaskErrorWithErr(basetask.ErrInvalidArgument, "command not found or not executable", e)
+		default:
+			return "", basetask.NewTaskErrorWithErr(basetask.ErrInternal, "failed to start process", err)
+		}
+	}
+
+	// Get the process group ID
+	pgid, err := syscall.Getpgid(cmd.Process.Pid)
+	if err != nil {
+		// if we fail to get pgid fallback to PID
+		pgid = cmd.Process.Pid
+	}
+
+	// we can now safely close the CgroupFD
+	cgroupFd.Close()
+
+	task := &Task{
+		ID:        taskID,
+		StartTime: time.Now(),
+		ClientID:  clientCN.(string),
+		Status:    basetask.JobStatusStarted,
+		ProcessID: pgid,
+	}
+
+	tm.AddTask(task)
+
+	// Start monitoring the process
+	go tm.monitorProcess(taskID, cmd)
+
+	return taskID, nil
+}
diff --git a/internal/task/manager/stop.go b/internal/task/manager/stop.go
new file mode 100644
index 0000000..dc0f254
--- /dev/null
+++ b/internal/task/manager/stop.go
@@ -0,0 +1,39 @@
+package task
+
+import (
+	"context"
+	"syscall"
+
+	basegrpc "github.com/mikewurtz/taskman/internal/grpc"
+	basetask "github.com/mikewurtz/taskman/internal/task"
+)
+
+func (tm *TaskManager) StopTask(ctx context.Context, taskID string) error {
+	task, err := tm.GetTask(taskID)
+	if err != nil {
+		return err
+	}
+
+	caller := ctx.Value(basegrpc.ClientIDKey).(string)
+	if task.ClientID != caller && caller != "admin" {
+		return basetask.NewTaskError(basetask.ErrNotFound, "task with id %s not found", taskID)
+
+	}
+
+	if !task.EndTime.IsZero() {
+		return basetask.NewTaskError(basetask.ErrFailedPrecondition, "task has already completed")
+	}
+
+	if err := syscall.Kill(-task.ProcessID, syscall.SIGKILL); err != nil {
+		return basetask.NewTaskErrorWithErr(basetask.ErrInternal, "failed to send SIGKILL to process group", err)
+	}
+
+	task.mu.Lock()
+	task.TerminationSource = "user"
+	if caller == "admin" {
+		task.TerminationSource = "admin"
+	}
+	task.mu.Unlock()
+
+	return nil
+}
diff --git a/internal/task/status.go b/internal/task/status.go
new file mode 100644
index 0000000..3624f3f
--- /dev/null
+++ b/internal/task/status.go
@@ -0,0 +1,32 @@
+package task
+
+import (
+	pb "github.com/mikewurtz/taskman/gen/proto"
+)
+
+// Internal job status constants
+const (
+	JobStatusUnknown = iota
+	JobStatusStarted
+	JobStatusSignaled
+	JobStatusExitedOK
+	JobStatusExitedError
+)
+
+// StatusToProto converts internal status strings to proto JobStatus enum
+func StatusToProto(internal int) (pb.JobStatus, error) {
+	switch internal {
+	case JobStatusUnknown:
+		return pb.JobStatus_JOB_STATUS_UNKNOWN, nil
+	case JobStatusStarted:
+		return pb.JobStatus_JOB_STATUS_STARTED, nil
+	case JobStatusSignaled:
+		return pb.JobStatus_JOB_STATUS_SIGNALED, nil
+	case JobStatusExitedOK:
+		return pb.JobStatus_JOB_STATUS_EXITED_OK, nil
+	case JobStatusExitedError:
+		return pb.JobStatus_JOB_STATUS_EXITED_ERROR, nil
+	default:
+		return pb.JobStatus_JOB_STATUS_UNKNOWN, NewTaskError(ErrInternal, "unknown internal job status: %q", internal)
+	}
+}
diff --git a/tests/integration/auth_test.go b/tests/integration/auth_test.go
new file mode 100644
index 0000000..954e317
--- /dev/null
+++ b/tests/integration/auth_test.go
@@ -0,0 +1,154 @@
+package integration
+
+import (
+	"context"
+	"testing"
+	"time"
+
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+)
+
+// tests a valid client cert but has no common name for unary calls (stop, start, get-status)
+func TestIntegration_NoCNInKeyUnary(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client-no-cn")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Unauthenticated, sts.Code())
+}
+
+// tests a valid client cert but has no common name for stream call
+func TestIntegration_NoCNInKeyStream(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client-no-cn")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	require.NoError(t, err)
+
+	resp, err := stream.Recv()
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Unauthenticated, sts.Code())
+
+}
+
+// tests a key that is self signed and not by a CA
+func TestIntegration_SelfSignedCertNoCA(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "badclient-self-signed")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Unavailable, sts.Code())
+}
+
+// tests a weak key that is RSA 512
+func TestIntegration_WeakKey512(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "weak")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Unavailable, sts.Code())
+}
+
+func TestIntegration_StartTaskTestAuthorization(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "ls",
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+
+	// try to get the task status using a different client
+	client2 := createTestClient(t, "client002")
+	statusResp, err := client2.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+		TaskId: resp.TaskId,
+	})
+	require.Nil(t, statusResp)
+	require.Error(t, err)
+	sts, ok = status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.NotFound, sts.Code())
+
+	// try to stop the task status using a different client
+	_, err = client2.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	require.Error(t, err)
+	sts, ok = status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.NotFound, sts.Code())
+
+	// get the status of the task using the admin client
+	adminClient := createTestClient(t, "admin")
+	var adminStatusResp *pb.TaskStatusResponse
+	require.Eventually(t, func() bool {
+		adminStatusResp, err = adminClient.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		// wait for the task to exit with and error
+		return err == nil && adminStatusResp != nil && adminStatusResp.Status == pb.JobStatus_JOB_STATUS_EXITED_OK
+	}, 3*time.Second, pollInterval, "expected task to exit without error")
+
+	assert.Equal(t, pb.JobStatus_JOB_STATUS_EXITED_OK, adminStatusResp.Status)
+	assert.Empty(t, adminStatusResp.TerminationSource)
+	assert.Empty(t, adminStatusResp.TerminationSignal)
+	assert.NotNil(t, adminStatusResp.EndTime)
+	assert.NotNil(t, adminStatusResp.StartTime)
+	assert.NotEmpty(t, adminStatusResp.ProcessId)
+	assert.Equal(t, resp.TaskId, adminStatusResp.TaskId)
+	assert.NotNil(t, adminStatusResp.ExitCode)
+	assert.Equal(t, int32(0), *adminStatusResp.ExitCode)
+}
diff --git a/tests/integration/cgroup_test.go b/tests/integration/cgroup_test.go
new file mode 100644
index 0000000..12d05ec
--- /dev/null
+++ b/tests/integration/cgroup_test.go
@@ -0,0 +1,196 @@
+package integration
+
+import (
+	"context"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"syscall"
+	"testing"
+	"time"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+func parseCPUStat(t *testing.T, content string) map[string]uint64 {
+	t.Helper()
+	stats := make(map[string]uint64)
+	for _, line := range strings.Split(content, "\n") {
+		if line == "" {
+			continue
+		}
+		parts := strings.Fields(line)
+		if len(parts) != 2 {
+			t.Fatalf("invalid cpu.stat line: %q", line)
+		}
+		val, err := strconv.ParseUint(parts[1], 10, 64)
+		if err != nil {
+			t.Fatalf("invalid value in cpu.stat line: %q: %v", line, err)
+		}
+		stats[parts[0]] = val
+	}
+	return stats
+}
+
+func TestIntegration_StartTaskOOMKilledPerl(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "perl",
+		Args:    []string{"-e", "my $x = \"A\" x (128 * 1024 * 1024); sleep 5;"},
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+
+	var statusResp *pb.TaskStatusResponse
+	require.Eventually(t, func() bool {
+		statusResp, err = client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		// wait for the task to exit with and error
+		return err == nil && statusResp != nil && statusResp.Status == pb.JobStatus_JOB_STATUS_SIGNALED
+	}, 3*time.Second, pollInterval, "expected task to exit with error")
+
+	assert.Equal(t, pb.JobStatus_JOB_STATUS_SIGNALED, statusResp.Status)
+	assert.Equal(t, "oom", statusResp.TerminationSource)
+	assert.Equal(t, syscall.SIGKILL.String(), statusResp.TerminationSignal)
+	assert.NotEmpty(t, statusResp.ProcessId)
+	assert.NotNil(t, statusResp.EndTime)
+	assert.NotNil(t, statusResp.StartTime)
+	assert.Equal(t, resp.TaskId, statusResp.TaskId)
+	assert.Nil(t, statusResp.ExitCode)
+}
+
+func TestIntegration_StartTaskIOThrottled(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "dd",
+		Args: []string{
+			"if=/dev/sda",
+			"of=/dev/null",
+			"bs=1M",
+			"count=5",
+			"iflag=direct",
+		},
+	})
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+
+	require.Eventually(t, func() bool {
+
+		ioStatPath := filepath.Join("/sys/fs/cgroup", resp.TaskId, "io.stat")
+		data, readErr := os.ReadFile(ioStatPath)
+		if readErr != nil {
+			t.Logf("waiting for io.stat: %v", readErr)
+			return false
+		}
+
+		lines := strings.Split(strings.TrimSpace(string(data)), "\n")
+		if len(lines) == 0 {
+			return false
+		}
+
+		fields := strings.Fields(lines[0])
+		if len(fields) < 2 {
+			return false
+		}
+
+		stats := make(map[string]uint64)
+		for _, field := range fields[1:] {
+			parts := strings.SplitN(field, "=", 2)
+			if len(parts) == 2 {
+				val, err := strconv.ParseUint(parts[1], 10, 64)
+				if err == nil {
+					stats[parts[0]] = val
+				}
+			}
+		}
+
+		return stats["rbytes"] > 0
+
+	}, 10*time.Second, 100*time.Millisecond, "expected task to complete and io.stat to reflect I/O")
+
+	// stop the task to clean up after ourselves
+	// the stop request will return ok if the task is stopped with our request
+	// or failed precondition if the task if already completed
+	_, err = client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	require.True(t, sts.Code() == codes.OK || sts.Code() == codes.FailedPrecondition)
+}
+
+func TestIntegration_CPUThrottled_BashLoop(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	// Start a CPU-bound task using bash busy loop
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "bash",
+		Args:    []string{"-c", "while :; do :; done"},
+	})
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+
+	var (
+		statusResp *pb.TaskStatusResponse
+		cpuStats   map[string]uint64
+	)
+
+	require.Eventually(t, func() bool {
+		// Confirm the task is running
+		statusResp, err = client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		if err != nil || statusResp == nil || statusResp.Status != pb.JobStatus_JOB_STATUS_STARTED {
+			return false
+		}
+
+		// Try reading cpu.stat while task is running
+		cpuStatPath := filepath.Join("/sys/fs/cgroup", resp.TaskId, "cpu.stat")
+		data, readErr := os.ReadFile(cpuStatPath)
+		if readErr != nil {
+			t.Logf("cpu.stat not ready yet: %v", readErr)
+			return false
+		}
+		cpuStats = parseCPUStat(t, string(data))
+		return cpuStats["nr_throttled"] > 0 && cpuStats["throttled_usec"] > 0
+	}, 10*time.Second, pollInterval, "expected task to start and cpu.stat to show throttling")
+
+	// stop the task to clean up after ourselves
+	// the stop request will return ok if the task is stopped with our request
+	// or failed precondition if the task if already completed
+	_, err = client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	require.True(t, sts.Code() == codes.OK || sts.Code() == codes.FailedPrecondition)
+}
diff --git a/tests/integration/main_test.go b/tests/integration/main_test.go
new file mode 100644
index 0000000..e694a6e
--- /dev/null
+++ b/tests/integration/main_test.go
@@ -0,0 +1,160 @@
+package integration
+
+import (
+	"context"
+	"crypto/tls"
+	"crypto/x509"
+	"errors"
+	"fmt"
+	"os"
+	"testing"
+	"time"
+
+	"github.com/mikewurtz/taskman/certs"
+	"github.com/mikewurtz/taskman/internal/grpc/server"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/credentials"
+	"google.golang.org/grpc/status"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+)
+
+const (
+	testTimeout  = 5 * time.Second
+	pollInterval = 100 * time.Millisecond
+	exitCode2    = int32(2)
+	testUserID   = "client001"
+)
+
+var (
+	testServerAddr string
+)
+
+func TestMain(m *testing.M) {
+	stopServer, err := startTestServer()
+	if err != nil {
+		fmt.Println("failed to start test server:", err)
+		os.Exit(1)
+	}
+
+	code := m.Run()
+	if stopServer != nil {
+		stopServer()
+	}
+	os.Exit(code)
+}
+
+// startTestServer starts the test server and returns a function to stop it
+// will only be called once
+func startTestServer() (func(), error) {
+	srv, err := server.New("localhost:0", context.Background())
+	if err != nil {
+		return nil, fmt.Errorf("failed to create test server: %w", err)
+	}
+
+	go func() {
+		if err := srv.Start(); err != nil {
+			fmt.Printf("Test server error: %v\n", err)
+		}
+	}()
+
+	stopServer := func() {
+		srv.Stop()
+	}
+
+	testServerAddr = srv.Addr()
+	client, conn, err := createClient(testUserID)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create gRPC client: %w", err)
+	}
+	defer func() {
+		if err := conn.Close(); err != nil {
+			fmt.Printf("failed to close gRPC connection: %v\n", err)
+		}
+	}()
+
+	// wait for the server to be ready to handle requests, 2 seconds should be plenty
+	deadline := time.Now().Add(2 * time.Second)
+	for time.Now().Before(deadline) {
+		// set context timeout to 500ms so we can still retry a few times if it fails
+		ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
+		_, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+		})
+		cancel()
+
+		sts, ok := status.FromError(err)
+		if ok && sts.Code() == codes.NotFound {
+			// Server is ready we can return
+			return stopServer, nil
+		}
+		// Pause briefly before retrying
+		time.Sleep(10 * time.Millisecond)
+	}
+
+	return nil, errors.New("gRPC server did not start in time")
+}
+
+func createClient(userID string) (pb.TaskManagerClient, *grpc.ClientConn, error) {
+	if userID == "" {
+		userID = testUserID
+	}
+
+	certPath := userID + ".crt"
+	keyPath := userID + ".key"
+
+	certPEM, err := certs.CertFiles.ReadFile(certPath)
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to read embedded client cert: %w", err)
+	}
+
+	keyPEM, err := certs.CertFiles.ReadFile(keyPath)
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to read embedded client key: %w", err)
+	}
+
+	cert, err := tls.X509KeyPair(certPEM, keyPEM)
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to parse key pair: %w", err)
+	}
+
+	caCert, err := certs.CertFiles.ReadFile("ca.crt")
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to read embedded CA cert: %w", err)
+	}
+
+	caPool := x509.NewCertPool()
+	if !caPool.AppendCertsFromPEM(caCert) {
+		return nil, nil, errors.New("failed to append CA cert to pool")
+	}
+
+	tlsConfig := &tls.Config{
+		Certificates: []tls.Certificate{cert},
+		RootCAs:      caPool,
+	}
+
+	conn, err := grpc.NewClient(
+		testServerAddr,
+		grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)),
+	)
+	if err != nil {
+		return nil, nil, fmt.Errorf("failed to set up gRPC client: %w", err)
+	}
+
+	return pb.NewTaskManagerClient(conn), conn, nil
+}
+
+func createTestClient(t *testing.T, userID string) pb.TaskManagerClient {
+	t.Helper()
+
+	client, conn, err := createClient(userID)
+	require.NoError(t, err, "failed to create gRPC client")
+
+	t.Cleanup(func() {
+		err := conn.Close()
+		require.NoError(t, err, "failed to clean up gRPC connection")
+	})
+	return client
+}
diff --git a/tests/integration/start_test.go b/tests/integration/start_test.go
new file mode 100644
index 0000000..e86a575
--- /dev/null
+++ b/tests/integration/start_test.go
@@ -0,0 +1,263 @@
+package integration
+
+import (
+	"context"
+	"syscall"
+	"testing"
+	"time"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+func TestIntegration_StartTaskContextCanceled(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithCancel(context.Background())
+	cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "ls",
+		Args:    []string{"-l"},
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Canceled, sts.Code())
+}
+
+func TestIntegration_StartTaskExitsError(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "ls",
+		Args:    []string{"/nonexistent"},
+	})
+	require.NoError(t, err)
+	require.NotNil(t, resp)
+	require.NotEmpty(t, resp.TaskId)
+
+	var statusResp *pb.TaskStatusResponse
+
+	require.Eventually(t, func() bool {
+		statusResp, err = client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		// wait for the task to exit with and error
+		return err == nil && statusResp != nil && statusResp.Status == pb.JobStatus_JOB_STATUS_EXITED_ERROR
+	}, 3*time.Second, pollInterval, "expected task to exit with error")
+
+	assert.Equal(t, pb.JobStatus_JOB_STATUS_EXITED_ERROR, statusResp.Status)
+	assert.Equal(t, "", statusResp.TerminationSource)
+	assert.Equal(t, "", statusResp.TerminationSignal)
+	assert.NotNil(t, statusResp.EndTime)
+	assert.NotNil(t, statusResp.StartTime)
+	assert.Equal(t, resp.TaskId, statusResp.TaskId)
+	assert.Equal(t, exitCode2, *statusResp.ExitCode)
+}
+
+func TestIntegration_StartTaskCommandDoesNotExistInPath(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "test-command-that-does-not-exist",
+	})
+	require.Error(t, err)
+	require.Nil(t, resp)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.InvalidArgument, sts.Code())
+	assert.Contains(t, sts.Message(), "invalid command")
+	assert.Contains(t, sts.Message(), "executable file not found in $PATH")
+}
+
+func TestIntegration_StartTaskFullPathCommandDoesNotExist(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "/path/to/test-command-that-does-not-exist",
+	})
+	require.Error(t, err)
+	require.Nil(t, resp)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.InvalidArgument, sts.Code())
+	assert.Contains(t, sts.Message(), "command not found")
+	assert.Contains(t, sts.Message(), "no such file or directory")
+}
+
+func TestIntegration_StartTask(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "ls",
+		Args:    []string{"-l"},
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+}
+
+func TestIntegration_StartTaskWithFullPath(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "/bin/ls",
+		Args:    []string{"-l"},
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+}
+
+func TestIntegration_StartTaskStopImmediately(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "sleep",
+		Args:    []string{"5"},
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+
+	stopCtx, stopCancel := context.WithTimeout(context.Background(), 1*time.Second)
+	defer stopCancel()
+
+	// stop the task immediately
+	stopResp, err := client.StopTask(stopCtx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	require.NoError(t, err)
+	stopSts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, stopSts.Code())
+	assert.NotNil(t, stopResp)
+
+	// get the status of the task
+	var statusResp *pb.TaskStatusResponse
+	require.Eventually(t, func() bool {
+		statusResp, err = client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		// wait for the task to exit with and error
+		return err == nil && statusResp != nil && statusResp.Status == pb.JobStatus_JOB_STATUS_SIGNALED
+	}, 3*time.Second, pollInterval, "expected task to exit with error")
+
+	assert.Equal(t, pb.JobStatus_JOB_STATUS_SIGNALED, statusResp.Status)
+	assert.Equal(t, "user", statusResp.TerminationSource)
+	assert.Equal(t, syscall.SIGKILL.String(), statusResp.TerminationSignal)
+	assert.NotNil(t, statusResp.EndTime)
+	assert.NotNil(t, statusResp.StartTime)
+	assert.NotEmpty(t, statusResp.ProcessId)
+	assert.Equal(t, resp.TaskId, statusResp.TaskId)
+	assert.Nil(t, statusResp.ExitCode)
+}
+
+func TestIntegration_StartTaskStopImmediatelyAttemptToStopAgain(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "sleep",
+		Args:    []string{"5"},
+	})
+	assert.NotNil(t, resp)
+	assert.NotEmpty(t, resp.TaskId)
+	require.NoError(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, sts.Code())
+
+	stopCtx, stopCancel := context.WithTimeout(context.Background(), 1*time.Second)
+	defer stopCancel()
+
+	// stop the task immediately
+	stopResp, err := client.StopTask(stopCtx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	require.NoError(t, err)
+	stopSts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.OK, stopSts.Code())
+	assert.NotNil(t, stopResp)
+
+	// get the status of the task
+	var statusResp *pb.TaskStatusResponse
+	require.Eventually(t, func() bool {
+		statusResp, err = client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+			TaskId: resp.TaskId,
+		})
+		// wait for the task to exit with and error
+		return err == nil && statusResp != nil && statusResp.Status == pb.JobStatus_JOB_STATUS_SIGNALED
+	}, 3*time.Second, pollInterval, "expected task to exit with error")
+
+	assert.Equal(t, pb.JobStatus_JOB_STATUS_SIGNALED, statusResp.Status)
+	assert.Equal(t, "user", statusResp.TerminationSource)
+	assert.Equal(t, syscall.SIGKILL.String(), statusResp.TerminationSignal)
+	assert.NotNil(t, statusResp.EndTime)
+	assert.NotNil(t, statusResp.StartTime)
+	assert.NotEmpty(t, statusResp.ProcessId)
+	assert.Equal(t, resp.TaskId, statusResp.TaskId)
+	assert.Nil(t, statusResp.ExitCode)
+
+	// attempt to stop the task again
+	stopResp2, err := client.StopTask(stopCtx, &pb.StopTaskRequest{
+		TaskId: resp.TaskId,
+	})
+	require.Error(t, err)
+	stopSts2, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.FailedPrecondition, stopSts2.Code())
+	assert.Nil(t, stopResp2)
+	assert.Contains(t, stopSts2.Message(), "task has already completed")
+}
diff --git a/tests/integration/status_test.go b/tests/integration/status_test.go
new file mode 100644
index 0000000..54973af
--- /dev/null
+++ b/tests/integration/status_test.go
@@ -0,0 +1,66 @@
+package integration
+
+import (
+	"context"
+	"testing"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+func TestIntegration_GetTaskStatusContextTimeout(t *testing.T) {
+	t.Parallel()
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithCancel(context.Background())
+	cancel()
+
+	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
+		Command: "ls",
+		Args:    []string{"-l"},
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Canceled, sts.Code())
+}
+
+func TestIntegration_GetTaskStatusContextCanceled(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithCancel(context.Background())
+	cancel()
+
+	resp, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Canceled, sts.Code())
+}
+
+func TestIntegration_GetTaskStatusDoesNotExist(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.NotFound, sts.Code())
+}
diff --git a/tests/integration/stop_test.go b/tests/integration/stop_test.go
new file mode 100644
index 0000000..781455f
--- /dev/null
+++ b/tests/integration/stop_test.go
@@ -0,0 +1,48 @@
+package integration
+
+import (
+	"context"
+	"testing"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+)
+
+func TestIntegration_StopTaskContextCanceled(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithCancel(context.Background())
+	cancel()
+
+	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Canceled, sts.Code())
+}
+
+func TestIntegration_StopTaskDoesNotExist(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.NotFound, sts.Code())
+}
diff --git a/tests/integration/stream_test.go b/tests/integration/stream_test.go
new file mode 100644
index 0000000..d62ed42
--- /dev/null
+++ b/tests/integration/stream_test.go
@@ -0,0 +1,53 @@
+package integration
+
+import (
+	"context"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+	"github.com/stretchr/testify/require"
+	"google.golang.org/grpc/codes"
+	"google.golang.org/grpc/status"
+
+	pb "github.com/mikewurtz/taskman/gen/proto"
+)
+
+func TestIntegration_StreamTaskOutputContextCanceled(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithCancel(context.Background())
+	cancel()
+
+	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+
+	assert.Nil(t, stream)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Canceled, sts.Code())
+}
+
+func TestIntegration_StreamTaskOutput(t *testing.T) {
+	t.Parallel()
+
+	client := createTestClient(t, "client001")
+
+	ctx, cancel := context.WithTimeout(context.Background(), testTimeout)
+	defer cancel()
+
+	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
+		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
+	})
+	require.NoError(t, err)
+
+	resp, err := stream.Recv()
+	assert.Nil(t, resp)
+	require.Error(t, err)
+	sts, ok := status.FromError(err)
+	require.True(t, ok)
+	assert.Equal(t, codes.Unimplemented, sts.Code())
+}
diff --git a/tests/integration_test.go b/tests/integration_test.go
deleted file mode 100644
index 43f490d..0000000
--- a/tests/integration_test.go
+++ /dev/null
@@ -1,404 +0,0 @@
-package tests
-
-import (
-	"context"
-	"crypto/tls"
-	"crypto/x509"
-	"errors"
-	"fmt"
-	"os"
-	"testing"
-	"time"
-
-	"github.com/stretchr/testify/assert"
-	"github.com/stretchr/testify/require"
-	"google.golang.org/grpc"
-	"google.golang.org/grpc/codes"
-	"google.golang.org/grpc/credentials"
-	"google.golang.org/grpc/status"
-
-	"github.com/mikewurtz/taskman/certs"
-	pb "github.com/mikewurtz/taskman/gen/proto"
-	"github.com/mikewurtz/taskman/internal/grpc/server"
-)
-
-const (
-	testUserID = "client001"
-)
-
-var (
-	testServerAddr string
-)
-
-func TestMain(m *testing.M) {
-	stopServer, err := startTestServer()
-	if err != nil {
-		fmt.Println("failed to start test server:", err)
-		os.Exit(1)
-	}
-
-	code := m.Run()
-	stopServer()
-	os.Exit(code)
-}
-
-// startTestServer starts the test server and returns a function to stop it
-// will only be called once
-func startTestServer() (func(), error) {
-	srv, err := server.New("localhost:0")
-	if err != nil {
-		return nil, fmt.Errorf("failed to create test server: %w", err)
-	}
-
-	go func() {
-		if err := srv.Start(); err != nil {
-			fmt.Printf("Test server error: %v\n", err)
-		}
-	}()
-
-	stopServer := func() {
-		srv.Stop()
-	}
-
-	testServerAddr = srv.Addr()
-	client, conn, err := createClient(testUserID)
-	if err != nil {
-		return nil, fmt.Errorf("failed to create gRPC client: %w", err)
-	}
-	defer func() {
-		if err := conn.Close(); err != nil {
-			fmt.Printf("failed to close gRPC connection: %v\n", err)
-		}
-	}()
-
-	// wait for the server to be ready to handle requests, 2 seconds should be plenty
-	deadline := time.Now().Add(2 * time.Second)
-	for time.Now().Before(deadline) {
-		// set context timeout to 500ms so we can still retry a few times if it fails
-		ctx, cancel := context.WithTimeout(context.Background(), 500*time.Millisecond)
-		_, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
-			TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-		})
-		cancel()
-
-		sts, ok := status.FromError(err)
-		if ok && sts.Code() == codes.Unimplemented {
-			// Server is ready we can return
-			return stopServer, nil
-		}
-		// Pause briefly before retrying
-		time.Sleep(10 * time.Millisecond)
-	}
-
-	return nil, errors.New("gRPC server did not start in time")
-}
-
-func createClient(userID string) (pb.TaskManagerClient, *grpc.ClientConn, error) {
-	if userID == "" {
-		userID = testUserID
-	}
-
-	certPath := userID + ".crt"
-	keyPath := userID + ".key"
-
-	certPEM, err := certs.CertFiles.ReadFile(certPath)
-	if err != nil {
-		return nil, nil, fmt.Errorf("failed to read embedded client cert: %w", err)
-	}
-
-	keyPEM, err := certs.CertFiles.ReadFile(keyPath)
-	if err != nil {
-		return nil, nil, fmt.Errorf("failed to read embedded client key: %w", err)
-	}
-
-	cert, err := tls.X509KeyPair(certPEM, keyPEM)
-	if err != nil {
-		return nil, nil, fmt.Errorf("failed to parse key pair: %w", err)
-	}
-
-	caCert, err := certs.CertFiles.ReadFile("ca.crt")
-	if err != nil {
-		return nil, nil, fmt.Errorf("failed to read embedded CA cert: %w", err)
-	}
-
-	caPool := x509.NewCertPool()
-	if !caPool.AppendCertsFromPEM(caCert) {
-		return nil, nil, errors.New("failed to append CA cert to pool")
-	}
-
-	tlsConfig := &tls.Config{
-		Certificates: []tls.Certificate{cert},
-		RootCAs:      caPool,
-	}
-
-	conn, err := grpc.NewClient(
-		testServerAddr,
-		grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)),
-	)
-	if err != nil {
-		return nil, nil, fmt.Errorf("failed to set up gRPC client: %w", err)
-	}
-
-	return pb.NewTaskManagerClient(conn), conn, nil
-}
-
-func createTestClient(t *testing.T, userID string) pb.TaskManagerClient {
-	t.Helper()
-
-	client, conn, err := createClient(userID)
-	require.NoError(t, err, "failed to create gRPC client")
-
-	t.Cleanup(func() {
-		err := conn.Close()
-		require.NoError(t, err, "failed to clean up gRPC connection")
-	})
-	return client
-}
-
-func TestIntegration_StartTask(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
-		Command: "ls",
-		Args:    []string{"-l"},
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unimplemented, sts.Code())
-}
-
-func TestIntegration_GetTaskStatus(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unimplemented, sts.Code())
-}
-
-func TestIntegration_StreamTaskOutput(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	require.NoError(t, err)
-
-	resp, err := stream.Recv()
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unimplemented, sts.Code())
-}
-
-func TestIntegration_StopTask(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unimplemented, sts.Code())
-}
-
-func TestIntegration_StopTaskContextCanceled(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithCancel(context.Background())
-	cancel()
-
-	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Canceled, sts.Code())
-}
-
-func TestIntegration_StartTaskContextCanceled(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithCancel(context.Background())
-	cancel()
-
-	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
-		Command: "ls",
-		Args:    []string{"-l"},
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Canceled, sts.Code())
-}
-
-func TestIntegration_GetTaskStatusContextCanceled(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithCancel(context.Background())
-	cancel()
-
-	resp, err := client.GetTaskStatus(ctx, &pb.TaskStatusRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Canceled, sts.Code())
-}
-
-func TestIntegration_StreamTaskOutputContextCanceled(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithCancel(context.Background())
-	cancel()
-
-	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-
-	assert.Nil(t, stream)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Canceled, sts.Code())
-}
-
-func TestIntegration_GetTaskStatusContextTimeout(t *testing.T) {
-	t.Parallel()
-	client := createTestClient(t, "client001")
-
-	ctx, cancel := context.WithCancel(context.Background())
-	cancel()
-
-	resp, err := client.StartTask(ctx, &pb.StartTaskRequest{
-		Command: "ls",
-		Args:    []string{"-l"},
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Canceled, sts.Code())
-}
-
-// tests a valid client cert but has no common name for unary calls (stop, start, get-status)
-func TestIntegration_NoCNInKeyUnary(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client-no-cn")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unauthenticated, sts.Code())
-}
-
-// tests a valid client cert but has no common name for stream call
-func TestIntegration_NoCNInKeyStream(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "client-no-cn")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	stream, err := client.StreamTaskOutput(ctx, &pb.StreamTaskOutputRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	require.NoError(t, err)
-
-	resp, err := stream.Recv()
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unauthenticated, sts.Code())
-
-}
-
-// tests a key that is self signed and not by a CA
-func TestIntegration_SelfSignedCertNoCA(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "badclient-self-signed")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unavailable, sts.Code())
-}
-
-// tests a weak key that is RSA 512
-func TestIntegration_WeakKey512(t *testing.T) {
-	t.Parallel()
-
-	client := createTestClient(t, "weak")
-
-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
-	defer cancel()
-
-	resp, err := client.StopTask(ctx, &pb.StopTaskRequest{
-		TaskId: "375b0522-72ed-4f3f-88d0-01d360d06b8c",
-	})
-	assert.Nil(t, resp)
-	require.Error(t, err)
-	sts, ok := status.FromError(err)
-	require.True(t, ok)
-	assert.Equal(t, codes.Unavailable, sts.Code())
-}
